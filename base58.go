// Package base58 implements base58 encoding and decoding as used by Bitcoin.
// Convenience functions are provided for encoding and decoding Bitcoin keys and hashes.
package base58

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math/big"
)

// Supported Bitcoin Base58Check prefixes.
// See https://en.bitcoin.it/wiki/List_of_address_prefixes for more information.
const (
	BitcoinPublicKeyHashPrefix             = "00"
	BitcoinScriptHashPrefix                = "05"
	BitcoinExtendedPublicKeyPrefix         = "0488b21e"
	BitcoinExtendedPrivateKeyPrefix        = "0488ade4"
	BitcoinPrivateKeyPrefix                = "80"
	BitcoinTestnetPublicKeyHashPrefix      = "6f"
	BitcoinTestnetScriptHashPrefix         = "c4"
	BitcoinTestnetExtendedPublicKeyPrefix  = "043587cf"
	BitcoinTestnetExtendedPrivateKeyPrefix = "04358394"
)

const kMinPrefixLength = 1
const kMaxPrefixLength = 4
const kChecksumLength = 4

var base58alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

// Reverse lookup of base58alphabet generated by init().
var base58reverse []int

// Map from prefixes to the expected length of the data they prefix.
var bitcoinPrefixToLength = map[string]int{
	BitcoinPublicKeyHashPrefix:             20,
	BitcoinScriptHashPrefix:                20,
	BitcoinExtendedPublicKeyPrefix:         74,
	BitcoinExtendedPrivateKeyPrefix:        74,
	BitcoinPrivateKeyPrefix:                32,
	BitcoinTestnetPublicKeyHashPrefix:      20,
	BitcoinTestnetScriptHashPrefix:         20,
	BitcoinTestnetExtendedPublicKeyPrefix:  74,
	BitcoinTestnetExtendedPrivateKeyPrefix: 74,
}

func getPrefix(data []byte) ([]byte, error) {
	if len(data) < 1 {
		return nil, fmt.Errorf("Input too short.")
	}
	// TODO Make the lookup mechanismmore generic.
	if data[0] == 0x04 {
		prefix := hex.EncodeToString(data[0:4])
		_, found := bitcoinPrefixToLength[prefix]
		if found {
			return data[0:4], nil
		} else {
			return nil, fmt.Errorf("Prefix %q not recognized.", prefix)
		}
	} else {
		prefix := hex.EncodeToString(data[0:1])
		_, found := bitcoinPrefixToLength[prefix]
		if found {
			return data[0:1], nil
		} else {
			return nil, fmt.Errorf("Prefix %q not recognized.", prefix)
		}
	}
}

func init() {
	base58reverse = make([]int, 256)
	for i, _ := range base58reverse {
		base58reverse[i] = -1
	}
	for i, c := range base58alphabet {
		base58reverse[int(c)] = i
	}
}

func reverseInplace(data []byte) {
	for i := 0; i < len(data)/2; i++ {
		tmp := data[i]
		data[i] = data[len(data)-i-1]
		data[len(data)-i-1] = tmp
	}
}

func EncodedMaxLen(x int) int {
	return 2 * x
}

func CheckEncodedMaxLen(x int) int {
	return EncodedMaxLen(x + kChecksumLength + kMaxPrefixLength)
}

// Encode encodes src into EncodedMaxLen(len(src))
// or fewer bytes of dst. It returns the number of bytes written to dst.
func Encode(dst, src []byte) int {
	zeros := 0
	for _, b := range src {
		if int(b) == 0 {
			zeros++
		} else {
			break
		}
	}
	i := new(big.Int).SetBytes(src)
	big58 := big.NewInt(58)
	big0 := big.NewInt(0)

	var index int
	for i.Cmp(big0) > 0 {
		tmp := new(big.Int).Mod(i, big58)
		i.Div(i, big58)
		dst[index] = base58alphabet[tmp.Int64()]
		index++
	}
	for ; zeros > 0; zeros-- {
		dst[index] = base58alphabet[0]
		index++
	}
	reverseInplace(dst[0:index])
	return index
}

// CheckEncode encodes prefix, src and a checksum into
// CheckEncodedMaxLen(len(src)) or fewer bytes of dst.
// It returns the number of bytes written to dst.
func CheckEncode(dst, prefix, src []byte) int {
	var buf bytes.Buffer
	buf.Write(prefix)
	buf.Write(src)
	buf.Write(checksum(buf.Bytes()))
	return Encode(dst, buf.Bytes())
}

// CheckEncodeToString returns the prefixed and checksummed base58 encoding of src.
func CheckEncodeToString(prefix, src []byte) string {
	dst := make([]byte, CheckEncodedMaxLen(len(src)))
	n := CheckEncode(dst, prefix, src)
	return string(dst[0:n])
}

func checksum(data []byte) []byte {
	first := sha256.Sum256(data)
	second := sha256.Sum256(first[:])
	return second[0:kChecksumLength]
}

// BitcoinCheckEncode returns the prefixed and checksummed base58 encoding of data.
// The size of the data must be valid for the prefix provided.
func BitcoinCheckEncode(prefix string, data []byte) (string, error) {
	length, found := bitcoinPrefixToLength[prefix]
	if !found {
		return "", fmt.Errorf("Prefix %q is not supported.", prefix)
	}
	if len(data) != length {
		return "", fmt.Errorf("Unexpected length for key prefix %q; "+
			"got %d, expected %d.", prefix, len(data), length)
	}
	h, _ := hex.DecodeString(prefix) // Can't fail if found in length map.
	return CheckEncodeToString(h, data), nil
}

func DecodedMaxLen(x int) int {
	return x
}

// Decode decodes src into DecodeMaxLen(len(src)) or fewer bytes,
// returning the actual number of bytes written to dst.
//
// If Decode encounters invalid input, it returns an error describing the failure.
func Decode(dst, src []byte) (int, error) {
	zeros := 0
	for _, b := range src {
		if b == base58alphabet[0] {
			zeros++
		} else {
			break
		}
	}
	big58 := big.NewInt(58)
	i := big.NewInt(0)
	for _, c := range src {
		i.Mul(i, big58)
		val := base58reverse[int(c)]
		if val < 0 {
			return 0, fmt.Errorf("Bad character %q in input.", c)
		}
		i.Add(i, big.NewInt(int64(val)))
	}
	length := len(i.Bytes()) + zeros
	if len(dst) < length {
		return 0, fmt.Errorf("Destination buffer not big enough; "+
			"need %d, got %d.", length, len(dst))
	}
	copy(dst[zeros:length], i.Bytes())
	return length, nil
}

func verifyChecksum(data []byte) bool {
	check := data[len(data)-kChecksumLength : len(data)]
	if !bytes.Equal(check, checksum(data[0:len(data)-kChecksumLength])) {
		return false
	}
	return true
}

// CheckDecode decodes src into DecodeMaxLen(len(src)) or fewer bytes and
// verifies the checksum. It returns the encoded version and actual number
// of bytes written to dst.
//
// If Decode encounters invalid input, it returns an error describing the failure.
func CheckDecode(dst, src []byte) (int, []byte, error) {
	if len(src) < kChecksumLength+kMinPrefixLength {
		return 0, nil, fmt.Errorf("Input too short.")
	}
	n, err := Decode(dst, src)
	if err != nil {
		return 0, nil, fmt.Errorf("Failed to decode input (%s): %v",
			src, err)
	}
	if !verifyChecksum(dst[0:n]) {
		return 0, nil, fmt.Errorf("Checksum mismatch.")
	}
	prefix, err := getPrefix(dst[0:n])
	if err != nil {
		// If prefix is unrecognized, assume it's the first byte.
		prefix = dst[0:1]
	}
	return n - kChecksumLength - len(prefix), prefix, nil
}

// CheckDecodeString returns the bytes represented by the checksummed
// and base58 encoded string s.
func CheckDecodeString(s string) ([]byte, []byte, error) {
	if len(s) < kChecksumLength+kMinPrefixLength {
		return nil, nil, fmt.Errorf("Input too short.")
	}
	dst := make([]byte, DecodedMaxLen(len(s)))
	n, err := Decode(dst, []byte(s))
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to decode input (%s): %v",
			s, err)
	}
	if !verifyChecksum(dst[0:n]) {
		return nil, nil, fmt.Errorf("Checksum mismatch.")
	}
	prefix, err := getPrefix(dst[0:n])
	if err != nil {
		// If prefix is unrecognized, assume it's the first byte.
		prefix = dst[0:1]
	}
	return dst[len(prefix) : n-kChecksumLength], prefix, nil
}

// BitcoinCheckDecode decodes a checksummed and base58 encoded Bitcoin key or hash.
// It returns the data and the prefix it was encoded with.
func BitcoinCheckDecode(src string) ([]byte, string, error) {
	dst, prefixBytes, err := CheckDecodeString(src)
	if err != nil {
		return nil, "", err
	}
	prefix := hex.EncodeToString(prefixBytes)
	length, found := bitcoinPrefixToLength[prefix]
	if !found {
		return nil, "", fmt.Errorf("Key has unsupported prefix %q.", prefix)
	}
	if len(dst) != length {
		return nil, "", fmt.Errorf("Unexpected length for key with prefix %q; "+
			"got %d, expected %d.", prefix, len(dst), length)
	}
	return dst, prefix, nil
}
